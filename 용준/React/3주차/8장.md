# 최적화

## 최적화와 메모이제이션

- 최적화: 웹 서비스의 성능을 개선하는 기술
- 리액트 앱에서 연산 최적화는 대부분 메모이제이션 기법을 사용함
- 메모이제이션: 특정 입력에 대한 결과를 계산해 메모리 어딘가에 저장했다가, 동일한 요청이 들어오면 저장한 결과값을 제공해 빠르게 응답하는 기술

## 함수의 불필요한 재호출 방지하기

- `useMemo`는 메모이제이션 기법을 이용해 연산의 결과값을 기억했다가 필요할 때 사용함으로써 불필요한 함수 호출을 막아주는 리액트 훅

### useMemo를 이용해 앱 최적화하기

```js
const value = useMemo(콜백함수, 의존성배열);
```

- 의존성 배열에 담긴 값이 바뀌면 콜백 함수를 다시 실행하고 결과값을 반환함

```js
const analyzeTodo = useMemo(() => {
  console.log("asd");
  const totalCount = todo.length;
  const doneCount = todo.filter((it) => it.isDone).length;
  const notDoneCount = totalCount - doneCount;
  return {
    totalCount,
    doneCount,
    notDoneCount,
  };
}, [todo]);
```

## 불필요한 컴포넌트 리렌더 방지하기

- `React.memo`를 이용하면 메모이제이션 기법으로 컴포넌트가 불필요하게 리렌더되는 상황을 방지할 수 있음

### 고차 컴포넌트와 횡단 관심사

#### 고차 컴포넌트(Higher Order Component, HOC)

- 컴포넌트의 기능을 다시 사용하기 위한 리액트의 고급 기술
- 인수로 전달된 컴포넌트를 새로운 컴포넌트로 반환하는 기술
- 기능을 추가해 반환한 컴포넌트를 강화된 컴포넌트라고 함

#### 횡단 관심사(Cross-Cutting Concerns)

- 로깅, 데이터베이스 접속, 인가 등 여러 곳에서 호출해 사용하는 코드를 말함
- 공통 기능들이 핵심 컴포넌트들을 횡단하는 모습을 연상하게 해 이러한 이름이 붙음
- 고차 컴포넌트를 이용하면 횡단 관심사 코드를 함수로 분리할 수 있음

### React.memo를 이용해 앱 최적화 하기

- 메모이제이션을 적용하고 싶은 컴포넌트를 `React.memo`로 감싸면 됨

```js
// React.memo의 용법
const memoizedComp = React.memo(메모이제이션하려는 컴포넌트);

// 함수 컴포넌트 선언과 동시에 메모이제이션도 가능
const CompA = React.memo(() => {
  return <div>CompA</div>;
});
```

- `React.memo`는 Props의 변경 여부를 기준으로 컴포넌트의 리렌더 여부를 결정함
- Props에 전달되는 값이 많을 때는 판별 함수를 인수로 전달해 Props의 특정 값만으로 리렌더 여부를 판단할 수 있음

```js
const Comp = ({ a, b, c }) => {
  return <div>Comp</div>;
};

function areEqual(prev, next) {
  if (prev.a === next.a) {
    return true;
  } else {
    return false;
  }
}
```

- 하지만 TodoItem 컴포넌트에 `React.memo`를 적용해도 불필요한 리렌더가 발생함
- 이는 todo가 업데이트되어 App 컴포넌트가 리렌더됐기 때문
- 동일한 기능을 수행하는 함수라도 다른 참조값을 갖게 되기 때문에 `React.memo`는 Props가 변한 것으로 판단함
- 이러한 리렌더를 방지하기 위해 `useCallback` 시용

## 불필요한 함수 재생성 방지하기

- `useCallback`은 컴포넌트가 리렌더될 때 내부에 작성된 함수를 다시 생성하지 않도록 메모이제이션하는 리액트 훅

### useCallback을 이용해 앱 최적화하기

#### useCallback의 기본 사용법

- useCallback은 메모이제이션된 함수를 반환함

```js
const memoizedFunc = useCallback(콜백함수, 의존성배열);
```

- 첫 번째 인수로 전달한 콜백 함수를 어떤 경우에도 다시 생성되지 않게 하려면 의존성 배열을 빈 배열로 전달하면 됨

#### useCallback과 함수형 업데이트

- useCallback의 첫 번째 인수로 전달한 콜백 함수에서 State 변수에 접근하는 경우 문제가 발생할 수 있음
- 콜백 함수가 컴포넌트의 마운트 시점 이후에는 다시 생성되지 않게 코드를 작성했을 경우, 마운트할 때의 State 값만 사용할 수 있음
- 이는 함수형 업데이트 기능을 이용하면 됨

```js
const onCreate = useCallback(() => {
  setState((state) => [newItem, ...state]);
}, []);
```

### 최적화할 때 유의할 점

1. 최적화는 항상 마지막에

- 최적화 이후에 만든 기능을 수정하거나 확장하기 어렵기 때문

2. 모든 것을 최적화할 필요는 없음

- 복잡하고 비싼 연산을 수행하거나, 리스트처럼 컴포넌트가 반복적으로 나타날 것이 예상되는 지점을 대상으로 진행

3. 컴포넌트 구조를 잘 설계했는지 돌아보기

- 컴포넌트를 기능이나 역할 단위로 잘 분리했는지 먼저 확인한 후 최적화하기
