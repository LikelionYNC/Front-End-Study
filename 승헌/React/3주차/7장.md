## 7장 useReducer와 상태 관리

---

## useReducer 이해하기

리액트 훅 useReducer를 이용하면 컴포넌트에서 상태 변화 코드를 쉽게 분리할 수 있다.

**상태 변화 코드란?**

상태 변화 코드란 State 값을 변경하는 코드다.

```jsx
const onIncrease = () => {
  setCount(count + 1);
};
const onDecrease = () => {
  setCount(count - 1);
};
```

useState를 이용해 State를 만들면 상태 변화 코드를 분리할 수 없다. 둘 다 컴포넌트 안에서 선언했기 때문이다. use State를 이용해 State를 생성하면 상태 변화 코드는 반드시 컴포넌트 안에 작성해야 한다. 반면 useReducer를 사용하면 상태 변화 코드를 컴포넌트 밖으로 분리할 수 있다.

**useReducer의 기본 사용법**

useReducer는 useState와 더불어 리액트 컴포넌트에서 State를 관리하는 리액트 훅이다. useReducer는 State 관리를 컴포넌트 내부가 아닌 외부에서 할 수 있게 만든다. 그래서 useState와 달리 State를 관리하는 상태 변화 코드를 컴포넌트와 분리할 수 있다.

```jsx
const [count, dispatch] = useReducer(reducer, 0);
// state 변수, 상태 변화 촉발 함수, 생성자
```

## [할 일 관리] 앱 업그레이드

**useState를 useReducer로 바꾸기**

useRedcer는 State를 관리하는 리액트 훅으로 useState의 대체자라고 할 수 있다. 실무에서는 컴포넌트를 관리하는 State가 복잡하지 않으면 useState를 사용하고, 그렇지 않으면 useReducer를 사용한다.

```jsx
function reducer(state, action) {
  switch (action.type) {
    case "CREATE": {
      return [action.newItem, ...state];
    }
    case "UPDATE": {
      return state.map((item) =>
        item.id === action.targetId ? { ...item, isDone: !item.isDone } : item
      );
    }
    case "DELETE": {
      return state.filter((item) => item.id !== action.targetId);
    }
    default:
      return state;
  }
}

function App() {
  const idRef = useRef(3);
  const [todo, dispatch] = useReducer(reducer, mockTodo);

  const onCreate = (content) => {
    dispatch({
      type: "CREATE",
      newItem: {
        id: idRef.current,
        isDone: false,
        content,
        createdDate: new Date().getTime(),
      },
    });
    idRef.current += 1;
  };

  const onUpdate = (targetId) => {
    dispatch({
      type: "UPDATE",
      targetId,
    });
  };

  const onDelete = (targetId) => {
    dispatch({
      type: "DELETE",
      targetId,
    });
  };
```
