## 8장 최적화

---

## 최적화와 메모이제이션

최적화란 웹 서비스의 성능을 개선하는 기술이다. 또한 프로그래밍에서 불필요하게 낭비되는 연산을 줄여 렌더링의 성능을 높이는 방법이다. 최적화가 잘 된 웹 서비스는 사용자를 불필요하게 기다리지 않게 만들며, 결국 서비스에 대한 사용자 경험을 긍정적으로 만든다.

리액느 앱에서 연산 최적화는 대부분 메모이제이션 기법을 이용한다. 메모이제이션은 특정 입력에 대한 결과를 계산해 메모리 어딘가에 저장했다가, 동일한 요청이 들오어면 저장한 결괏값을 제공해 빠르게 응답하는 기술이다. 결과적으로 이 기법을 이용하면 불필요한 연산을 줄여 주어 프로그램의 실행 속도를 빠르게 만든다. 알고리즘에서는 이를 동적 계획법(Dynamic Programming, DP)라 부른다.

## 함수의 불필요한 재호출 방지하기

usememo는 메모이제이션 기법을 이용햐 연산의 결과값을 기억했다가 필요할 때 사용함으로써 불필요한 함수 호출을 막아 주는 리액트 훅이다.

**할 일 분석 기능 추가하기**

```jsx
const analyzeTodo = () => {
  const totalCount = todo.length;
  const doneCount = todo.filter((it) => it.isDone).length;
  const notDoneCount = totalCount - doneCount;
  return {
    totalCount,
    doneCount,
    notDoneCount,
  };
};
const { totalCount, doneCount, notDoneCount } = analyzeTodo();
```

**문제점 파악하기**

할 일 아이템을 분석하는 함수는 todo에 저장한 아이템 개수에 비례해 수행할 연산량이 증가한다. 만약 todo에 저장한 아이템 개수가 많아지면 성능상의 문제를 일으킬 가능성이 있다.

**useMemo를 이용해 [할 일 관리] 앱 최적화하기**

useMemo의 용법

```jsx
const value = useMemo(callback, deps);
// 콜백 함수, 의존성 배열
```

**함수 analyzeTodo의 재호출 방지하기**

```jsx
const analyzeTodo = useMemo(() => {
  const totalCount = todo.length;
  const doneCount = todo.filter((it) => it.isDone).length;
  const notDoneCount = totalCount - doneCount;
  return {
    totalCount,
    doneCount,
    notDoneCount,
  };
}, [todo]);
const { totalCount, doneCount, notDoneCount } = analyzeTodo;
```

## 불필요한 컴포넌트 리렌더 방지하기

React.memo를 이용하면 메모이제이션 기법으로 컴포넌트가 불필요하게 리렌더되는 상황을 방지할 수 있다.

**고차 컴포넌트**

HOC는 Higher Order Component의 약자로 고차 컴포넌트라고 한다. 고차 컴포넌트의 기능을 다시 사용하기 위한 리액트의 고급 기술로, useMemo, useEffect처럼 use 키워드가 앞에 붙는 리액트 훅과는 다르다

고차 컴포넌트는 인수로 전달된 컴포넌트를 새로운 컴포넌트로 반환하는 함수이다. 다만 고차 컴포넌트는 전달된 컴포넌트를 그대로 반환하는게 아니라 어떤 기능을 추가해 반환한다. 이렇게 기능을 추가해 반환한 컴포넌트를 강화된 컴포넌트라고 부른다.

**횡단 관심사**

고차 컴포넌트를 이용하면 횡단 관심사 문제를 효율적으로 해결할 수 있어 실무에서 많이 활용한다. 홍단 관심사란 크로스 커팅 관심사라고도 하는데, 프로그래밍에서 비지니스 로직과 구분되는 공통 기능을 지칭할 때 사용하는 용어다. 반면 비지니스 로직은 해당 컴포넌트가 존재하는 핵심 기능을 표현할 때 사용한다.

**React.memo를 이용해 [할 일 관리] 앱 최적화하기**

React.memo는 컴포넌트가 모든 상황에서 리렌더되지 않도록 강화함으로써 서비스를 최적화하는 도구다.

**React.memo 기본 사용법**

React.memo는 인수로 전달한 컴포넌트를 메모이제이션된 컴포넌트로 만들어 반환한다. 이때 Props가 메모이제이션의 기준이 된다. 즉, React.memo가 반환하는 컴포넌트는 부모 컴포넌트에서 전달된 Props가 변경되지 않는 한 리렌더되지 않는다. 컴포넌트가 크고 복잡할수록 불필요한 렌더링을 방지하면, 브라우저의 연산량을 줄여 주어 성능 최적화에 도움이 된다.

React.memo는 단지 강화하고 싶은, 메모이제이션을 적용하고 싶은 컴포넌트를 React.memo로 감싸면 된다.

```jsx
const memoizedComp = React.memo(Comp);
// 메모이제이션하려는 컴포넌트
```

**Header 컴포넌트의 리렌더 방지하기**

할 일 관리 앱의 Header 컴포넌트는 부모 컴포넌트인 App에서 아무런 Props도 받지 않는다. 이컴포넌트는 어떤 상황에서도 리렌더할 필요가 없다. 한마디로 불필요한 렌더링이다. React.memo로 감싸 해결해주자.

```jsx
export default React.memo(Header);
```

**TodoItem 컴포넌트 리렌더 방지하기**

TodoItem 컴포넌트에서 불필요한 렌더링이 일어나는지 확인하고 최적하하기

## 불필요한 함수 재생성 방지하기

useCallback은 컴포넌트가 리렌더될 때 내부에 작성된 함수를 다시 생성하지 않도록 메모이제이션하는 리액트 훅이다.

**useCallback을 이용해 [할 일 관리] 앱 최적화하기**

useCallback은 useMemo처럼 2개의 인수를 제공한다. 첫 번째 인수로는 메모이제이션하려는 콜백 함수를 전달하고, 두 번째 인수로는 의존성 배열을 전달한다. 결과로 useCallback은 메모이제이션된 함수를 반환한다.

```jsx
const memoizedFunc = useCallback(func, deps);
// 콜백 함수, 의존성 배열
```

useCallback은 의존성 배열에 담긴 값이 바뀌면 첫 번째 인수로 전달한 콜백 함수를 다시 만들어 반환한다. 만약 첫 번째 인수로 전달한 콜백 함수를 어떤 경우에도 다시 생성되지 않게 하려면 의존성 배열을 빈 배열로 전달하면 된다.

`const memoizedFunc = useCallback(func, [])`

**useCallback을 이용해 TodoItem 컴포넌트의 리렌더 방지하기**

```jsx
const onUpdate = useCallback((targetId) => {
  dispatch({
    type: "UPDATE",
    targetId,
  });
}, []);

const onDelete = useCallback((targetId) => {
  dispatch({
    type: "DELETE",
    targetId,
  });
}, []);
```

**최적화할 때 유의할 점**

최적화는 항상 마지막에 한다.

리액트 앱의 최적화는 보통 프로젝트 개발이 끝나고 가장 마지막에 진행하는 작업이다. 기능을 추가할 때마다 최적하를 진행하지 않고 마지먹에 한꺼번에 하는 이유는 최적화 이후에는 만든 기능을 수정하거나 확장하기 어렵기 때문이다.

**모든 것을 최적화할 필요는 없다**

리액트 앱에 있는 모든 컴포넌트의 아주 사소한 연산이나 리렌더까지 다 찾아내서 최적화할 필요는 없다. 이는 오히려 향후 서빗스 확장이나 기능 수정을 어렵게 만들 수 있다. 또한 전체적인 웹 서비스 성능 개선에도 큰 도움이 되지 않는다. 일반적으로 복잡하고 비싼 연산을 수행하거나, 리스트처럼 컴포넌트가 반복적으로 나타날 것이 예상되는 지점을 대상으로 진행한다.
