# 8장. 최적화

**학습 목표**

- 웹 서비스에서 최적화가 무엇인지 알아봅니다.
- 최적화에 사용되는 리액트 도구들을 알아봅니다.
- 실습으로 [할 일 관리] 앱을 최적화합니다.

## 최적화와 메모이제이션

최적화란 한마디로 웹 서비스의 성능을 개선하는 기술이다. 또한 프로그래밍에서 불필요하게 낭비되는 연산을 줄여 렌더링의 성능을 높이는 방법이다. 최적화가 잘 된 웹 서비스는 사용자를 불필요하게 기다리지 않게 만들며, 결국 서비스에 대한 사용자 경험을 긍정적으로 만든다.
리액트는 성능면에서 매우 빠르고 브라우저의 불필요한 연산도 최소화한다. 그러나 리액트라고 해서 프로그래머의 부주의나 실수로 인한 성능 저하까지 모두 막지는 못한다. 실수로 인한 성능 낭비는 프로그래머 자신이 바로잡아야 한다. 성능 저하를 줄이는 것이 훌륭한 서비스를 만드는 방법이며, 프로그래머에게 요구되는 핵심 역량이다.
최적화 방법으로는 코드, 폰트, 이미지 파일의 크기를 줄이는 등 여러 기술이 있지만, 내용이 방대할 뿐만 아니라 일부 방법은 아직 확실한 정답이 없다. 여기서는 최적화의 기본이라고 할 수 있는 리액트의 연산 낭비를 줄이는 데 초점을 둔다.
리액트 앱에서 연산 최적화는 대부분 메모이제이션이라는 기법을 이용한다. 메모이제이션이란 '메모하는 방법'이다. 메모이제이션은 특정 입력에 대한 결과를 계산해 메모리 어딘가에 저장했다가, 동일한 요청이 들어오면 저장한 결괏값을 제공해 빠르게 응답하는 기술이다. 결과적으로 이 기법을 이용하면 불필요한 연산을 줄여 주어 프로그램의 실행 속도를 빠르게 만든다. 알고리즘을 공부하는 사람들은 이 기능을 동적 계획법이라고 한다.

## 함수의 불필요한 재호출 방지하기

처음 살펴볼 리액트 최적화 관현 기능으로는 useMemo가 있다. useMemo는 메모이제이션 기법을 이용해 연산의 결괏값을 기억했다가 필요할 때 사용함으로써 불필요한 함수 호출을 막아 주는 리액트 훅이다.

### useMemo의 기본 사용법

useMemo를 사용하면 특정 함수를 호출했을 때 그 함수의 반환값을 기억한다. 그리고 같은 함수를 다시 호출하면 기억해 두었던 값을 반환한다. 따라서 useMemo를 이용하면 함수의 반환값을 다시 구하는 불필요한 연산을 수행하지 않아 성능을 최적화할 수 있다. 이처럼 함수의 연산 결과를 기억하는 행위를 메모이제이션한다고 한다.

[useMemo의 용법]
```jsx
const value = useMemo[callback, deps];
```

함수 useMemo를 호출하고 2개의 인수로 콜백함수와 의존성 배열(deps)를 전달한다. 호출된 useMemo는 의존성 배열에 담긴 값이 바뀌면 콜백 함수를 다시 실행하고 결괏값을 반환한다.
예를 들어 다음과 같이 useMemo를 사용하면 의존성 배열 count의 값이 변할 때만 count * count를 계산해 value에 저장한다

```jsx
const value = useMemo(() => {
    return count * count;
}, [count]);
```

- useMemo를 호출하고 첫 번째 인수로 메모이제이션하려는 콜백 함수를 전달한다. 이 함수는 두 번째 인수로 전달할 의존성 배열의 값이 변하지 않는 한 다시 호출되지 않는다.
- 의존성 배열로 [count]를 전달한다. 결과적으로 value에는 첫 번째 인수로 전달한 콜백 함수의 반환값이 저장된다. 만약 count의 값이 변하면 콜백 함수를 다시 호출해 변경된 변환값을 value에 저장한다.

## 불필요한 컴포넌트 리랜더 방지하기

두 번째로 살펴볼 리액트의 최적화 기능은 React.memo이다. React.memo를 이용하면 메모이제이션 기법으로 컴포넌트가 불필요하게 리렌더되는 상황을 방지할 수 있다.

### 고차 컴포넌트와 횡단 관심사

React.memo를 이해하기 위해서는 먼저 고차 컴포넌트와 횡단 관심사에 관한 이해가 선행되어야 한다.

**고차 컴포넌트**

고차 컴포넌트는 인수로 전달된 컴포넌트를 새로운 컴포넌트로 변환하는 함수이다. 다만 고차 컴포넌트는 전달된 컴포넌트를 그대로 반환하는 게 아니라 어떤 기능을 추가해 반환한다. 이렇게 기능을 추가해 반환한 컴포넌트를 강화된 컴포넌트라고 부른다.

**횡단 관심사**

고차 컴포넌트를 이용하면 횡단 관심사 문제를 효율적으로 해결할 수 있어 실무에서 많이 활용한다. 횡단 관심사는 프로그래밍에서 비즈니스 로직과 구분되는 공통 기능을 지칭할 때 사용되는 용어이다. 반면 비즈니스 로직은 해당 컴포넌트가 존재하는 핵심 기능을 표현할 때 사용한다. 간단히 말하면 **여러 컴포넌트에서 공통적으로 사용되는 기능**이다.

### React.memo의 기본 사용법

React.memo는 인수로 전달한 컴포넌트를 메모이제이션된 컴포넌트로 만들어 반환한다. 이때 Props가 메모이제이션의 기준이 된다. 즉, React.memo가 반환하는 컴포넌트는 부모 컴포넌트에서 전달된 Props가 변경되지 않는 한 리렌더되지 않는다. 컴포넌트가 크고 복잡할수록 불필요한 렌더링을 방지하면, 브라우저의 연산량을 줄여 주어 성능 최적화에 도움이 된다.
React.memo를 사용하는 방법은 매우 간단하다. 단지 강화하고 싶은, 즉 메모이제이션을 적용하고 싶은 컴포넌트를 React.memo로 감싸면 된다.

[React.memo의 용법]
```jsx
const memoizedComp = React.memo(Comp);

// OR

const CompA = React.memo(() => {
    console.log('컴포넌트가 호출되었습니다.');
    return <div>CompA</div>;
});
```

React.memo는 Props의 변경 여부를 기준으로 컴포넌트의 리렌더 여부를 결정한다. 만약 Props로 전달되는 값이 많을 때는 다음과 같이 판별 함수를 인수로 전달해 Props의 특정 값만으로 리렌더 여부를 판단할 수 있다.

```jsx
const Comp = ({ a, b, c }) => {
    console.log('컴포넌트가 호출되었습니다.');
    return <div>CompA</div>;
};

function areEqual (prevProps, nextProps) {
    if (prevProps. a === nextProps.a) {
        return true;
    } else {
        return false;
    }
}

const MemoizedComp = React.memo(Comp, areEqual);
```

- 판별 함수로 사용할 함수 areEqual을 만든다. 판별 함수에는 두 개의 매개변수가 제공되는데, prevProps에는 이전 Props의 값, nextProps에는 새롭게 바뀐 Props의 값이 각각 저장된다. 판별 함수가 true를 반환하면 리렌더되지 않고, 판별 함수가 false를 반환하면 리렌더된다.
- Comp 컴포넌트를 메모이제이션하기 위해 React.memo를 호출하고 인수를 전달한다. 두 번째 인수로 판별 함수 areEqual을 전달한다. 그 결과로 반환되는 MemoizedComp는 전달되는 Prop의 값 중 a가 변경될 때만 리렌더링된다.

### 불필요한 함수 재생성 방지하기

useCallback은 컴포넌트가 리렌더될 때 내부에 작성된 함수를 다시 생성하지 않도록 메모이제이션하는 리액트 훅이다.

### useCallback의 기본 사용법

useCallback은 useMemo처럼 2개의 인수를 제공한다. 첫 번째 인수로는 메모이제이션하려는 콜백 함수를 전달하고, 두 번째 인수로는 의존성 배열을 전달한다. 결과로 useCallback은 메모이제이션된 함수를 반환한다.

[useCallback의 용법]
```jsx
const memoizedFunc = useCallback(func, deps);
```

useCallback은 의존성 배열에 담긴 값이 바뀌면 첫 번째 인수로 전달한 콜백 함수를 다시 만들어 반환한다. 만약 첫 번째 인수로 전달한 콜백 함수를 어떤 경우에도 다시 생성되지 않게 하려면 의존성 배열을 빈 배열로 전달하면 된다.

## 최적화 할 때 유의할 점

### 최적화는 항상 마지막에 할 것

리액트 앱의 최적화는 보통 프로젝트 개발이 끝나고 가장 마지막에 진행하는 작업이다. 기능을 추가할 때마다 최적화를 진행하지 않고 마지막에 한꺼번에 하는 이유는 최적화 이후에는 만든 기능을 수정하거나 확장하기 어렵기 때문이다.

### 모든 것을 최적화할 필요는 없다

리액트 앱에 있는 모든 컴포넌트의 아주 사소한 연산이나 리렌더까지 다 찾아내어 최적화할 필요는 없다. 이는 오히려 향후 서비스 확장이나 기능 수정을 어렵게 만들 수 있다. 또한 전체적인 웹 서비스 성능 개선에도 큰 도움이 되지 않는다. 최적화는 일반적으로 부하가 많으리라 예상되거나, 복잡하고 비싼 연산을 수행하거나, 리스트처럼 컴포넌트가 반복적으로 나타날 것이 예상되는 지점을 대상으로 진행한다.

### 컴포넌트 구조를 잘 설계했는지 다시 한번 돌아볼 것

어떤 개발자는 하나의 컴포넌트에 10개 또는 그 이상의 State와 State 관리 코드를 작성하고는 최적화하려고 한다. 하나의 컴포넌트에 이렇게 많은 State를 생성하는 것은 매우 비효율적이며 최적화하기도 어렵다. 따라서 컴포넌트를 기능이나 역할 단위로 잘 분리했는지 먼저 확인한 다음 최적화해야 한다.